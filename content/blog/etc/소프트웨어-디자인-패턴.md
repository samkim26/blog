---
title: 소프트웨어 디자인 패턴
date: 2021-08-04 20:08:63
category: etc
draft: false
---

## 디자인 패턴이란?

- 디자인 패턴은 소프트웨어 설계에서 흔히 발생하는 문제에 대한 해결책이다. 
- **패턴은 특정 코드가 아니라 특정 문제를 해결하기 위한 일반적인 개념**이다. 

## 우리가 디자인 패턴을 배워야(알아야) 하는 이유

- 디자인 패턴은 소프트웨어 설계에서 공통적인 문제에 대한 시도되고 테스트된 솔루션의 툴킷이다.
- 이런 문제를 만나지 못하더라도, 패턴을 아는 것은 객체 지향적인 디자인의 원리를 사용하여 모든 종류의 문제를 해결하는 방법을 가르쳐주기 때문에 유용하다.
- 디자인 패턴은 동료들과 더 효율적으로 의사소통하기 위해 사용할 수 있는 공통 언어를 정의한다.

## 디자인패턴 종류

### 생성 패턴(Creational Patterns)

객체 생성에 관련된 패턴이다. 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.

1. 싱글톤 패턴(Singleton) : 클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 글로벌 엑세스 포인트를 제공하는 패턴이다.

   - 프로그램의 클래스에 모든 클라이언트가 사용할 수 있는 단일 인스턴스가 있어야 하는 경우에 사용한다.

     - ex) 프로그램의 다른 부분에서 공유하는 단일 데이터페이스 객체

   - 글로벌 변수에 대해 엄격한 제어가 필요할 때 사용한다.

   - 장점

     - 클래스에 하나의 인스턴스만 있다고 확신할 수 있다.
     - 싱글톤 객체는 처음 요청될 때만 초기화된다.

   - 단점

     - 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유할 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져서 개방 폐쇄 원칙을 위반하게 된다.

     - 테스트가 어려워 질 수 있다.

     - 멀티스레드 환경에서 특별한 처리가 필요하다.

       ```java
       // JVM의 class loader의 매커니즘과 class의 load 시점을 이용하여 내부 class를 생성시킴으로 thread 간의 동기화 문제를 해결한다.
       
       // static이기 때문에 클래스 로딩시점에 한 번만 호출된다.
       // final을 사용해 다시 값이 할당되지 않도록 한다.
       public class ExampleClass {
         
       	private ExClass () {}
       	private static class Singleton {
         	private static final ExClass instance = new ExClass();
       	}
       	
       	public static ExClass getInstance () {
       		return Singleton.instance;
       	}
       }
       
       ```

2. 추상팩토리 패턴(Abstract Factory) : 구체적인 클래스를 지정하지 않고 관련성이 있거나, 독립적인 객체들을 생성하기 위한 인터페이스를 제공하는 패턴이다.

   - 구체적인 클래스를 지정하지 않고 관련 객체의 `집합`을 생성할 수 있는 창조적 설계 패턴이다.
   - 코드가 여러 관련 제품군과 함께 작동해야 하지만 다양한 제품의 구체적인 종류에 따라 코드가 달라지는 것을 원하지 않을 때 사용한다.
   - 장점
     - factory 에서 생산하는 제품이 서로 호환되는지 알 수 있다.
     - 제품과 클라이언트 코드 간의 긴밀한 결합을 피할 수 있다.
     - 단일 책임 원칙을 준수한다.
     - 개방 폐쇄 원칙을 준수한다. 기존 클라이언트 코드를 깨지 않고 새로운 변형 제품을 도입할 수 있다.

3. 빌더 패턴(Builder) : 복잡한 객체를 단계 별로 구성할 수 있게 해주는 패턴이다.

   - 번거로운 생성자 작업을 줄여준다.
   - 제품의 다양한 표현의 생산에서 세부사항만 다른 유사한 단계가 있을 때 사용한다.
   - composite 트리나 다른 복합적인 객체들을 생성하는 데에 사용한다.
   - 장점
     - 동일한 생산 코드를 재사용할 수 있다.
     - 단일 책임 원칙을 준수한다. 복잡한 코드를 제품의 비즈니스 로직에서 분리할 수 있다.
   - 단점
     - 새로운 클래스를 여러 개 만들어야하기 때문 코드의 전반적인 복잡성이 증가한다.

4. 팩토리 메서드 패턴(Factory Method) : 객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만드는 클래스는 서브클래스에서 결정하도록 하는 패턴이다. 팩토리 메서드에서는 인스턴스를 만드는 것을 서브 클래스에서 하게 된다.

   - 객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 한다.
   - 사용할 객체의 정확한 타입과 의존성을 모를 때 사용한다.
   - 라이브러리나 프레임워크 사용자에게 내부 구성요소를 확장할 수 있는 방법을 제공하고 싶을 때 사용한다.
   - 기존 객체를 재구성하는 대신 재사용하여 시스템 리소스를 절약하고 싶을 때 사용한다.
   - 장점
     - 긴밀한 결합을 피할 수 있다.
     - 단일 책임 원칙을 준수한다.
     - 개방 폐쇄 원칙을 준수한다.
   - 단점
     - 패턴을 구현하기 위한 많은 새로운 하위 클래스를 도입해야할 수도 있기 때문에 코드가 복잡해질 수 있다.

   ```
   많은 설계가 팩토리 메소드 패턴을 사용하는 것으로 시작하여 추상 팩토리 패턴, 프로토타입 패턴, 빌더 패턴으로 발전한다.
   ```

5. 원형 패턴(Prototype) : 생성할 객체의 종류를 명시하는 데 원형이 되는 예시물을 이용하고 새로운 객체를 이 원형들을 복사함으로써 생성하는 패턴이다.

   - 복사해야 할 객체의 구체적인 클래스에 의존하지 않아야 하는 경우 사용한다.

   - 각 객체를 초기화하는 방식이 다른 하위 클래스들의 수를 줄일 때 사용한다.

   - 장점

     - 구체 클래스에 연결하지 않고 객체를 복제할 수 있다.
     - 반복적인 초기화 코드를 제거할 수 있다.
     - 복잡한 객체를 편리하게 생산할 수 있다.
     - 복잡한 객체에 대한 구성 프리셋을 처리할 때 상속 대신 사용할 수 있다.

   - 단점

     - 순환 참조를 가지는 복잡한 객체를 복제하는 것은 까다로울 수도 있다.

       > 순환 참조 : `A -> B -> C -> A` 같이 꼬리를 무는 형태의 참조





---

## 추가

- [Examples of GoF Design Patterns in Java's core libraries](https://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns-in-javas-core-libraries) : '이 디자인패턴이 이런 Java 코어 라이브러리에 적용되었네?' 정도로 확인하면서 생각해보면 좋을 것 같다.

## 참고

- https://refactoring.guru/design-patterns/